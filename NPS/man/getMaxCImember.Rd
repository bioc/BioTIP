% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NPS.R
\name{getMaxCImember}
\alias{getMaxCImember}
\title{Identifying the 'Biomodule'}
\usage{
getMaxCImember(membersL, MCIl, minsize = 1)
}
\arguments{
\item{membersL}{A list of integer vectors with unique ids as names. Each
vector represents the cluster number assign to that unique id. The length
of this list is equal to the number of states in the study. This can be the
first element of the output from function \code{getMCI} or the output from
\code{getCluster_methods}, see Examples for more detail.}

\item{MCIl}{A list of numeric vectors with unique cluster number as names.
Each vector represents the MCI scores of that module. This can be the
second element of the output from function \code{getMCI}.}

\item{minsize}{A numerical value of the minimum module size (the number of
transcript in a cluster) to output for downstream analysis.}
}
\value{
A nested list whose length is the length of the input object
\code{membersL}.  Each internal list contains two objects, one object is
the vector of biomodule IDs cross states, and the other object is a list of
transcript IDs (each defines the biomodule per state) cross states.
}
\description{
This function reports the 'biomodule' which is the module with
the maximum Module Critical Index (MCI) scores for each state. Each state
can have multiple modules (groups of subnetworks derived from the function
\code{\link{ getCluster_methods}}). This function runs over all states.
}
\examples{
#1st option: get the input directly from getMCI function
test = list('state1' = matrix(sample(1:10,6),4,3),'state2' = matrix(sample(1:10,6),4,3),'state3' = matrix(sample(1:10,6),4,3))

# assign colnames and rownames to the matrix
for(i in names(test)){
  colnames(test[[i]]) = 1:3
    row.names(test[[i]]) = c('g1','g2','g3','g4')}

cluster = list(c(1,2,2,1),c(1,2,3,1),c(2,2,1,1))
names(cluster) = names(test)
for(i in names(cluster)){
  names(cluster[[i]]) = c('g1','g2','g3','g4')}

membersL_noweight <- getMCI(cluster,test)
maxMCIms <- getMaxMCImember(membersL_noweight[[1]], membersL_noweight[[2]], min =3)
#The same as
maxMCIms <- getMaxMCImember(cluster, membersL_noweight[[2]], min =2)

#2nd option: get the input directly from function "getCluster_methods"
test = list('state1' = matrix(sample(1:10,6),2,3),'state2' = matrix(sample(1:10,6),2,3),'state3' = matrix(sample(1:10,6),2,3))
# assign colnames and rownames to the matrix
for(i in names(test)){
  colnames(test[[i]]) = 1:3
  row.names(test[[i]]) = 1:2}

igraphL <- getNetwork(test, fdr=1)
#[1] "state1:2 nodes"
#[1] "state2:2 nodes"
#[1] "state3:2 nodes"

#case1: using 'rw' method by default
cl <- getCluster_methods(igraphL)
#make sure every element in list cl is a \\code{communities} object
sapply(cl,class)
#       state1        state2        state3
#\\code{communities} \\code{communities} \\code{communities}
# if not, manually remove that state and then run
cluster = lapply(cl, membership)
maxCIms <- getMaxMCImember(cluster, membersL_noweight[[2]], min =2)

#or run function 'getMCI' and use the 1st option
membersL_noweight <- getMCI(cl,test)

# case2: using methods other than the default
cl <- getCluster_methods(igraphL,method = "pam")
maxCIms <- getMaxMCImember(cl, membersL_noweight[[2]], min =2)

}
\author{
Zhezhen Wang and Biniam Feleke
}
